import javax.crypto.Cipher;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.security.spec.KeySpec;
import java.util.Base64;

public class AESGCMWithPBKDF2Example {
    private static final int AES_KEY_SIZE = 256;  // AES key size in bits
    private static final int GCM_IV_LENGTH = 12;  // GCM IV length in bytes
    private static final int GCM_TAG_LENGTH = 128; // GCM tag length in bits
    private static final int SALT_LENGTH = 16; // Salt length in bytes

    public static void main(String[] args) throws Exception {
        // The password you want to use
        String password = "your_password_here";

        // Generate a random salt
        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[SALT_LENGTH];
        random.nextBytes(salt);

        // Generate the key from the password and salt
        SecretKeySpec keySpec = getKeyFromPassword(password, salt);

        // Generate a random IV
        byte[] iv = new byte[GCM_IV_LENGTH];
        random.nextBytes(iv);

        // The data you want to encrypt
        String data = "Hello, World!";

        // Encrypt the data
        String encryptedData = encrypt(keySpec, iv, data);

        // The encrypted data string includes the salt, iv, and encrypted data
        // Decrypt the data
        String decryptedData = decrypt(password, encryptedData);

        System.out.println("Decrypted data: " + decryptedData);
    }

    public static SecretKeySpec getKeyFromPassword(String password, byte[] salt) throws Exception {
        SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
        KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 10000, AES_KEY_SIZE);
        byte[] secretKey = factory.generateSecret(spec).getEncoded();
        return new SecretKeySpec(secretKey, "AES");
    }

    public static String encrypt(SecretKeySpec key, byte[] iv, String data) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
        cipher.init(Cipher.ENCRYPT_MODE, key, spec);
        byte[] encryptedData = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));

        // Concatenate salt, iv and encrypted data
        byte[] combined = new byte[SALT_LENGTH + GCM_IV_LENGTH + encryptedData.length];
        System.arraycopy(key.getEncoded(), 0, combined, 0, SALT_LENGTH);
        System.arraycopy(iv, 0, combined, SALT_LENGTH, GCM_IV_LENGTH);
        System.arraycopy(encryptedData, 0, combined, SALT_LENGTH + GCM_IV_LENGTH, encryptedData.length);

        return Base64.getEncoder().encodeToString(combined);
    }

    public static String decrypt(String password, String encryptedData) throws Exception {
        // Decode the base64 encoded string
        byte[] decodedData = Base64.getDecoder().decode(encryptedData);

        // Extract the salt and iv from the decoded data
        byte[] salt = new byte[SALT_LENGTH];
        System.arraycopy(decodedData, 0, salt, 0, SALT_LENGTH);

        byte[] iv = new byte[GCM_IV_LENGTH];
        System.arraycopy(decodedData, SALT_LENGTH, iv, 0, GCM_IV_LENGTH);

        // Re-create the key from the password and salt
        SecretKeySpec key = getKeyFromPassword(password, salt);

        // Decrypt the data
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
        cipher.init(Cipher.DECRYPT_MODE, key, spec);

        byte[] decryptedData = cipher.doFinal(decodedData, SALT_LENGTH + GCM_IV_LENGTH, decodedData.length - SALT_LENGTH - GCM_IV_LENGTH);
        return new String(decryptedData, StandardCharsets.UTF_8);
    }
}
